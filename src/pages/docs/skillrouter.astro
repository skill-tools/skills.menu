---
import Docs from '../../layouts/Docs.astro';
---

<Docs title="@skill-tools/router">
	<h1>@skill-tools/router</h1>
	<p>
		BM25 skill selection middleware for <a href="https://agentskills.io" target="_blank" rel="noopener">Agent Skills</a>.
		Uses full-text search to select which skills to inject into an agent's context window from large skill catalogs.
		Zero external dependencies &mdash; built-in Okapi BM25 engine.
	</p>

	<pre><code>npm install @skill-tools/router</code></pre>

	<h2>Quick Start</h2>
	<pre><code>import &#123; SkillRouter &#125; from '@skill-tools/router';

const router = new SkillRouter();

await router.indexSkills([
  &#123; name: 'deploy-vercel', description: 'Deploy apps to Vercel...' &#125;,
  &#123; name: 'run-tests', description: 'Execute test suites...' &#125;,
  &#123; name: 'lint-code', description: 'Run ESLint or Biome...' &#125;,
]);

const results = await router.select('deploy my app');
// [&#123; skill: 'deploy-vercel', score: 1.0, metadata: &#123;...&#125; &#125;]</code></pre>

	<h2>API</h2>

	<h3><code>SkillRouter</code></h3>
	<p>Main class. Constructor accepts optional <code>SkillRouterOptions</code> with embedding config and BM25 parameters.</p>

	<h3><code>indexSkills(skills)</code></h3>
	<p>Index skill descriptions into the BM25 inverted index. Tokenizes, removes stop words, and builds posting lists.</p>

	<h3><code>indexDirectory(dirPath)</code></h3>
	<p>Auto-discover and index SKILL.md files in a directory.</p>

	<h3><code>select(query, options?)</code></h3>
	<p>Find the top-K most relevant skills for a natural language query.</p>
	<table>
		<thead>
			<tr>
				<th>Option</th>
				<th>Default</th>
				<th>Description</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td><code>topK</code></td>
				<td>5</td>
				<td>Number of results</td>
			</tr>
			<tr>
				<td><code>threshold</code></td>
				<td>0.0</td>
				<td>Minimum BM25 score (normalized 0&ndash;1)</td>
			</tr>
			<tr>
				<td><code>boost</code></td>
				<td>&mdash;</td>
				<td>Skill names to boost by 1.2x</td>
			</tr>
			<tr>
				<td><code>exclude</code></td>
				<td>&mdash;</td>
				<td>Skill names or wildcard patterns to exclude</td>
			</tr>
		</tbody>
	</table>

	<h3><code>detectConflicts(threshold?)</code></h3>
	<p>Find skills with highly similar descriptions that may conflict.</p>

	<h3><code>save() / load(snapshot)</code></h3>
	<p>Serialize/restore the full index as JSON. Useful for instant startup persistence.</p>

	<h3><code>SkillRouter.fromSnapshot(snapshot)</code></h3>
	<p>Static factory to restore from a serialized snapshot.</p>

	<h2>BM25 Parameters</h2>
	<table>
		<thead>
			<tr>
				<th>Parameter</th>
				<th>Default</th>
				<th>Description</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td><code>k1</code></td>
				<td>1.2</td>
				<td>Term frequency saturation. Higher values give more weight to repeated terms.</td>
			</tr>
			<tr>
				<td><code>b</code></td>
				<td>0.75</td>
				<td>Length normalization. 0 = ignore length, 1 = fully normalize.</td>
			</tr>
		</tbody>
	</table>

	<pre><code>const router = new SkillRouter(&#123;
  bm25: &#123; k1: 1.5, b: 0.8 &#125;,
&#125;);</code></pre>

	<h2>Embedding Providers (Advanced)</h2>
	<p>By default, the router uses BM25 full-text search (zero dependencies). For custom semantic search, you can provide your own embedding function:</p>

	<pre><code>const router = new SkillRouter(&#123;
  embedding: &#123;
    provider: 'custom',
    dimensions: 1536,
    embed: async (texts) =&gt; &#123;
      // Call your embedding API here
      return texts.map(t =&gt; myEmbedFunction(t));
    &#125;,
  &#125;,
&#125;);</code></pre>

	<h2>Architecture</h2>
	<ul>
		<li><strong>Inverted index</strong> maps terms to posting lists &mdash; only documents containing query terms are scored</li>
		<li><strong>IDF pre-computation</strong> at index time for O(q) query performance</li>
		<li><strong>Float64Array</strong> score accumulator for efficient scoring</li>
		<li>Score normalization to [0, 1] &mdash; divide by max score per query</li>
		<li>Scales to 10,000+ skills with zero external dependencies</li>
		<li>Snapshot format includes inverted index, IDF cache, and BM25 parameters</li>
		<li>Dual-path: BM25 default, embedding + vector store fallback for custom providers</li>
	</ul>

	<h2>BM25Index (Direct Use)</h2>
	<p>The BM25 engine is also exported for standalone use:</p>
	<pre><code>import &#123; BM25Index &#125; from '@skill-tools/router';

const index = new BM25Index();
index.add('doc-1', 'Deploy applications to Vercel');
index.add('doc-2', 'Run unit tests with Vitest');

const results = index.search('deploy', &#123; topK: 5 &#125;);
// [&#123; id: 'doc-1', score: 1.0 &#125;]</code></pre>
</Docs>
